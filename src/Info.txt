This is an informational text file for Copy Paste Game.

To get to this project in CMD: 
cd \Users\"Mason Dunn"\eclipse-workspaceC\CopyPasteGame

Contents:
// Misc. Reminders
// Main ideas
// Widget Ideas
// Widget Traits
// refineMapString(vector<string>) function
// makeMapFromString(string) function
// Move Function
// Counters
// Possible Puzzles
// How Movement Works

[=============================================- @ -=============================================]
Misc. Reminders
[=============================================- @ -=============================================]
Miscellaneous reminders for anything that I want to remind myself of/make note of, but there isn't a devoted
section for it. It can also be said that it is for things that I may want to add in the future, but haven't
added yet, and thus they arguabley don't yet deserve to be considered actual information about the game,
as they don't yet describe any currently existing detail or facet of the game.

The edge of the map will be treated as a wall.

Spaces in the map string will be replaced with the empty space tile (maybe '-'?) in the rendered map.

If the rows in the map string are of unequal length, it will show up as a hole in the map, which will be treated
as a bunch of walls. Edit: Nvm, just replace it with actual space or walls.
Edit 2: Actually, uneven rows get filled in with *empty spaces*.

If there are multiple '@'s in the map, the player controls all of them. There should also allowed to be 0.
I might also allow for there to be 2 unique players. If so, player two would be '&'. 

After I have come up with a working movement system, try searching for alternatives in Google or the chat bot.
Not necessarily because it needs to be replaced with an alternative, but just for the sake of learning.

Enemy ideas: 
// An enemy that, once destoyed, gives you 1 or 2 dash-charges.
//
// An enemy that "slides", moving across an entire row or column until an obstacle. This can't push anything,
// though (or atleast, can only do it 1 block at a time). It destroys any player in its path.
// Perhaps if it "slides" into a pushable block, it pushes the block 1 space, eg:
// // 'S' is the slide enemy, 'P' is a pushable block.
// // S - - - - - - - - - - P -
// // - - - - - - - - - - S - P
// Notice the gap it left. This could prevent it from easily getting itself trapped in a pocket.

Perhaps "slide" could be an ability a player can have?

Perhaps there should be an ability that allows players to push, swap with, or otherwise rearrange immovable widgets.

There will be doors that require a specific number to be pushed into it to be destroyed (and it destroys that
number).


[=============================================- @ -=============================================]
Main Ideas
[=============================================- @ -=============================================]

The player inputs a string of text, which is then turned into the game map. 

List of tiles:
@ Player
- Empty space
# Wall
] New Row
C Coin Counter
J Jump Counter
* Coin (maybe change to $)
! Enemy
& Player 2?????????????????????

[=============================================- @ -=============================================]
Widget Ideas
[=============================================- @ -=============================================]

The player (and maybe player 2) (@ and &, respectively)

A standard enemey that makes a beeline for the player.

An enemy that can move an infinite amount of spaces horizontally or vertically. It's possible that this enemey HAS
to move as many spaces as it can before hitting a wall or other obstacle, killing anything in its path (possibly
destroying certain widgets that aren't "alive", such as weak walls). It's possible that, in order to "spot" the
player, the player must be on their row or column. However, it's also possible that they can spot the player from
anywhere, as long as they are nearby, and if the player isn't already in their row or column, this enemy will
attempt to make its way there. Maybe the enemy can only move horizontally OR vertically infinitely, but must move
by one space the other way. Eg, if they can move vertically infinitely, they can move horizontally by one.
-----
Maybe it just stays still. Maybe, it just waits for the player to enter its line of sight, at which points it
zooms towards them. Maybe, in orfer to get around this, the play must put a pushable block in front of it,
to sheild them from this enemy. Or perhaps, if the player goes to the spot one diagonal away from this enemy, it
will bait the enemy into moving ONE space orthogonally, allowing the player to kill the enemy via teleportation.

Weak walls. They behave like walls (of course), but can be destroyed by several means.

Thwomp (see chronolog). Perhaps the thwomp can move one space in any direction except downwards. To move downwards,
it must thwomp. Or perhaps it can only move up and down. Who knows? I suppose it is important to note that the
thwomp doesn't necessarily have to be an enemey that targets the player. Instead, it just moves up repeatedly,
until it reaches the ceiling, when it will then thwomp. It does this 

bait. Attracts enemies, and can possibly be "killed".

Bomb

Movers. These come in pairs and in several possible flavors. A mover is actually a pair of widgets:
a puller and a pusher (or a head and a tail). It's pretty simple: pullers attempt to flee from pushers, who in
turn chase the pullers. Flavors include:
- - Good pushers and good pullers: Can be pushed around by the player.
- - Evil pushers and evil pullers: Will destory the player if the player walks in to them (but won't pursue players)
- - Good smart pullers: They are like good pushers, EXCEPT that if they get pushed into a wall, they'll turn and move
- - - - in another direction, if possible, instead of simply stopping.
- - Evil smart pullers: They are like good smart pullers, but evil. They hurt.
- - Chaser pullers: Pullers that, aside from fleeing from pushers, will also chase the player. Can be good or evil

[=============================================- @ -=============================================]
Widget Traits
[=============================================- @ -=============================================]

This is a list of traits that each widget may or may not have:
// * Movable
// // * Can this widget be moved/pushed? Yes or no? Note: I may split this into 2 other traits:
// // Movable: Can it be moved directly?
// // Pushable: Can it be pushed by something else?
//
// * Dangerous:
// // * Yes or no? Dangerous widget can destroy players or player-aligned characters.
//
// * Number:
// // * Is the character a number? If so, it is given its respective number value. Otherwise, it's given a -1 value.
//
// * Player:
// // * Is it a player-controlled character? Yes or no?
//
// * Killable:
// // * Dashing through this widget will result in it being destroyed and added to the kill count

[=============================================- @ -=============================================]
refineMapString(vector<string>) function
[=============================================- @ -=============================================]

This is used to remove the spaces and newlines (not ']', '\n') from the input, which allows someone to input
something like this:
- - - ]
- @ - ]
- - - #

Instead of this: 
---]-@-]---#

For context, in the main function, the input for the map is obtained like this:
// The user inputs a string and presses enter.
// If they want, they can input another string. Otherwise, they can just press enter again, submiting an empty
-- // strng and ending the loop.
// Each string that gets submitted gets pushed onto a vector of strings.

So, the refineMapString function takes in this vector and goes through 2 for-loops:
// The first loop takes every string in the vector and adds them all to a single, temporary string, thus removing
-- // new line characters.
// The second row iterates through the temporary string, and adds each character to the an output string, as long as
-- // that character isn't a space (' ').

Finally, the function returns the output string. This was surprisingly and pleasantly easy to write, and didn't take
much time at all.

[=============================================- @ -=============================================]
makeMapFromString(string) function
[=============================================- @ -=============================================]

This function is supposed to take in the string that will be used to create the map.
It has 3 main parts:

Part 1: Is the input empty?
If the input is empty (input.length() < 1), then it passes a premade input string into the makeMapFromString
function (yes, it calls itself). This results in the function returning a premade, playable map, which tells the
user that their input is empty.

Part 2: How many rows and columns are there?
This uses a for loop and 2 other variables: biggestRowLength and currentRowLength. 
The loop will check 4 conditions:
// 1: If the current character in the input string (input[i]) is a newline character or the end of the input string,
// // AND the length of the current row is longer than the biggestRowLength, then it updates the biggestRowLength
// // and sets the currentRowLength = 1. 
// 2: If the current character is a newline character or the end of the input string, AND the current row is NOT
// // longer  than the biggestRowLength, then it just sets currentRowLength = 1;
// 3: Otherwise, increment currentRowLength
// 4: If the current character is a newline character, increment the rows variable (the one passed in by reference).
-
After the for-loop is over, it sets columns = biggestRowLength. It doesn't do anything to rows because it already
incremented it *during* the loop (see condition 4).
-
P.S.: the reason that currentRowLength is set to 1 and not 0 is because it knows that the current row length is at
least 1. It is also because currentRowLength isn't incremented when encountering a newline character or the last
character. So basically, it knows the the row is at least 1 character long (including the newline character or last
character), but if it encounters a character that isn't a newline or the last character, then it can safely increment
currentRowLength (because each line has either a newline character or the last character. So, if it encounters a
character that isn't one of these, then there MUST be at least 1 character in the row. Conversely,
if it encounters a newline character or the last character, then it KNOWS that there will be no more characters in
the row, which is why it doesn't increment currentRowLength) 

Part 3: Translate the input string to the output vector.
This part starts by creating 2 vectors: the actual 2D output vector, and a 1D "default row" vector.
// The 2D vector is initialized empty.
// The 1D vector is initialized to be the length of a row (`comlumns` variable), and each element is set to the 
// // empty space character.
It also creates an int (`positionInInput`) and a bool (`reachedEndOfInput`), which will be talked about later.
-
Here is the overall idea behind Part 3:
A default row is pushed onto the end of the output vector. Then, the program looks at each space in the row and
determines whether the current character in the input string should be added to the current space in the vector, or
if that space should be left as its default value (the empty space character).
For context, it will keep track of 3 "pointers." These are not actual pointers that need to be dereferenced.
Instead, they are just regular ints used to keep track of the current row, current column,
and current character in the input string.
There are 3 conditions:
// If the current character in the input string is a new row character, but the column "pointer" has not reached the
-- // end of the row yet, then it will just leave the current space in the vector as is. It will then advance the
-- // column pointer without advancing the input string's pointer.
// Else if the input string's pointer reaches the end of the input string (even if the row and column pointers have 
-- // not made it to the end of the vector yet), then it will simply stop the loop. This will leave all remaining
-- // spaces in the vector as the empty space character.
// Otherwise, it will simply assign the current character in the input string to the current space in the vector.
-- // It will then advance all 3 pointers.
-
An important thing to keep in mind in order to conceptualize the logic of Part 3:
Part 3 is centered around the output vector, not the input string. What this means is that it will iterate through
the vector, while also keeping track of the current character in the input string. Not the other way around.
It moves through the positions in the vector at a constant rate, but does not move through the input string at a
constant rate (it may refrain from moving the input string's pointer forward in the first condition)

[=============================================- @ -=============================================]
Move function
[=============================================- @ -=============================================]

See the section "How movement works" for more info.

This is the default ruleset for movement:
// The thing being moved can be one of four things:
// // Out of bounds/nonexistent object
// // Immovable object
// // Movable object
// // Empty air
//
// The spot being moved to can be one of four things:
// // Out of bounds
// // Occupied by an immovable object
// // Occupied by a movable object
// // Empty air
//
// If the moved object is at the end of a long line of objects being pushed (ie the recursive count is too high),
// the move fails.
//
// If the object being moved is out of bounds (it does not exits) the move fails.
// 
// If the object being moved is immovable the move fails.
//
// If the object being moved is movable then the function will check the adjacent space to be moved to and
// attempt to move there.
//
// Finally, if the object being moved is just empty air, nothing happens but the move is counted as successful.
//
//
// Assuming that the object being moved is movable, the function moves on and starts checking the adjacent space
// to be moved to.
//
// If the space being moved to is out of bounds, the move fails.
//
// If the space being moved to is occupied by an immovable object, the move fails.
//
// If the space being moved to is occupied by a movable object, then the function will call itself to move that
// object. Let this be called a "push move". If the push move is successful, then the initial move is too.
// Otherwise, the initial move fails.
//
// If the space being moved to is empty, then the move is successful.

Those are the default rules, but there are exceptions:
// If player 1 moves into another instance of player 1, then PERHAPS the first instance pushes the second instance,
// without incrementing recursiveCount.
//
// If a player moves onto a coin...
//
// If a player moves onto an enemy/hazard, the player disappears and the enemy/hazard is left alone (or maybe they
// get pushed before the player disappears).
//
// Maybe if a coin moves onto a player it will push the player (in which case it is not an exception to default
// rules).
//
// If an enemy moves onto the player...

[=============================================- @ -=============================================]
Counters
[=============================================- @ -=============================================]

List of counters:
// Coins

It's  possible that counters conpletely require a number to be next to them in order for them
to operate. For example, if there is a countdown counter(s), it can not kill the player unless there is
a zero next to it and no higher number. If there is no number next to it at all, the countdown won't kill you.
If a counter has absolutely no numbers next to it, its value is -1, not 0.

There will be a function for each type of counter. The function's purpose is to scan the map (yes, the whole map),
look for instance(s) of the counter widget in question, read the numbers that are next to the counter, and then
update the global variable that keeps track of whatever is being counted.
Keep in mind: This gloabl counter variable(s) will only be update via these function(s).
If a player steps on a coin, it will not update that globalCoinCount variable, it will simply
call the function whose job is to update the map so that a number next to a coin counter is increased
by 1. The globalCoinCount variable does not know about this until a function scans the map, looks at
each coin counter widget, and then sums up how many coins the player should have.
For example, if there is no coin counter (or if the coin counter(s) don't have a number attached) then the player can
step on as many coins as he can bring himself to. Yet, globalCoinCount will never rise above zero because
when the function is called, it will look at the map and see no sign of the player having collected a single cent.
In other words: The globalCoinCount variable is based off of the current state of the map, NOT actionas/events that
occur during a widget's turn. As such, nothing in the code, except these special functions are supposed to update the
counter variables (eg globalCoinCount) only the map itself is supposed to inform the counter, and any attempts to update
the value of a counter variable should be done vicariously via updating the map.
I will refer to the function as a counter-scanner. In the case of the coin counter, it will be called `scanCoinCounters()`.
How often should scanCoinCounters() be called? At the start of every "game cycle"? At the start of each widget's turn?
No and no, respectively.
It will be called whenever the globalCoinCount variable is about to be read from. Same for the other counter varables.

[=============================================- @ -=============================================]
Possible Puzzles
[=============================================- @ -=============================================]

There is a door next to a kill counter. A number widget is situated between and thus connected to both of them.
The number widget serves as the receptacle for the kill counter and the threshold for the door. The number that
widget represents is a low number. The player is provided with some dash charges, enough to kill all of the enemies
in the room that they are in. They are alos given a number widget of equal value of the door's threshold.
If the player kills any enemies, the kill counter updates its number widget, increasing the door's threshold, and
invalidating you "key". You must manuver past enemies and get the key to the door.

[=============================================- @ -=============================================]
How Movement Works
[=============================================- @ -=============================================]

See the section "Move function" for more info.

Perhaps during the player's turn, it will store a copy of the game map. If, by The end of the player's
sub-turn (not a full turn where everything/everyone moves, just the sub-turn where player(s) move) the game map
still looks the same as it did, that means that no instance of the player has moved, and the player must try
again. Of course, if there are no players on the map, the game will run with out the player.

This doesn't apply to just movement, but I may implement a sort of "action queue". It will be a global queue, who's
elements consist of a pair of coordinates and an action (possibly its own data type) that takes place there.
The queue will only consist of actions that occur simultaneously. It may even be a queue of queues, so as to store
future actions. 
The actions in the queue will occur starting with whatever is at the start.
I may actually not be able to use a queue, since I don't just want to deal with the action at the start of the
queue, but also any actions further down the line that that action affects.
A vector would suffice, then.
Perhaps I could make a custom data type clled "WidgetAction", containing a pair of coordinates, a char, and a
string, the latter of which will contain a description of the action to be performed.

What happens if there are two/multiple actions in the queue affecting the same widget? I have 4 possible solutions:
1 Keep the first instance of it, remove any following ones.
2 Keep the latest one, remove all of the prior ones.
3 Weigh them (and choose the one with the highest "score").
4 Do both of them.

In order for a movement to successfully happen, these criteria must be met:
* The widget actually wants to make that move(eg If player chooses right, the player widget won't want to move left)
* The movement does not conflict with other simultaneous moves.
* The movement is possible (eg not blocked by a wall)
If the widget decides that it does not want to make that move (unlikely that I will implement such a system), it is
allowed up to 3 more attempts to pick one (4 attempts total, one for each side/possible move).
// Actually, giving a widget the ability to rethink its move might be a bit advanced for now. For now, I may just
// just have a widget "decide" which move it wants to make, and then it commits to that move. If it is unable to
// actually accomplish that move, then it simply doesn't make the move. And then, in the future, I may go back
// and give them the ability to rethink. Of course, an exception is players: If there is at least 1 player on the
// board, if the player is unable to move, they must try again.

I can *probably* say that a widget will have "made up its mind" by the time it creates a WidgetAction and sends it
out to the action queue/vector.

For the time being, I will assume that different types of actions/events can not happen simultaneously.
This is to make it easier on me, as each type of action will have its own function for determining whether or
not it conflicts with any other simultaneous actions. So for example, a widget can't move at the exact same time
that a bomb is going off. One comes before the other.
While it is *possible* that I *may* want to change this in the future, for now and for the sake of progress, 
I will assume otherwise.


As of September 30, 2025, this is the overall idea of how movement conflicts might be handled:
- - First, all move requests are put into a vector.
- - It looks at each move request. Each request consists of a widget type, a start x & y, and
- - - - an end x & y.
- - For each move request, it looks at every move request that comes after. (Yes, this is O(N^2)).
- - If the destination of the current request is the same as the destination of a request further
- - - - down the line, it might simply cancel that move request, or perhaps it recursively checks if
- - - - that move will be successful. HOWEVER, this scenario (same destination) isn't necessarily
- - - - a conflict. EG:
- - - - - - - - - D - - - - D moves Down
- - - - - - - - R - - - - - R moves Right
- - - - - - - - - - - - - - 
# # # # # # # # # # # # # # 
- - - - - - - - - - - - - - 
- - - - - - - - - R D - - - End result. Both moves end up going through.
- - - - - - - - - - - - - - Edit: This might not happen.
- - If the destination of the current request is the starting point of another, it recursively
- - - - checks if that move will be succesful. If this recursion somehow manages to end up at
- - - - the original move request, all relevant move requests are cancled.
- - - - - - Or perhaps they all go through...
-----
For the time being, how about we just worry about that second case: If the destination of
the current request is the starting point of another, it recursively checks if that move will
be succesful. If this recursion somehow manages to end up at the original move request, all relevant
move requests are cancled. Or perhaps they all go through.
-----
In fact, for the time being, let's just assume that simultaneous moves actually happen
simultaneously, instead of them simply happening one at a time in the most logical order.
This means that this:
- D - 
R - - 
- - - 
Will result in this:
- - - 
R D - 
- - - 
Not this:
- - - 
- R D 
- - - 

Friday October 3 2025
- - Kyle and I thought of some more ideas as to how to deal with movement. Here are some ideas we
- - thought of:
- - Movement will be separated by direction. This means that there is no "movement" action, but 
- - rather "move up", "move right", "move down", and "move left" actions. Since different directions
- - are treated as separate movement types, they cannot happen simultaneously. So this:
- - - - - - 
- - - D - - 'D' moves down
- - R - - - 'R' moves right
- - - - - - 
- - results in this:
- - - - - - 
- - - - - - 
- - - R D - 
- - - - - -
- - Or maybe this, if 'R' moves first:
- - - - - - 
- - - - - - 
- - - D - - 
- - - R - - 
- - 
- - If each direction of movement is a unique movement type, then it makes certain things much easier.
- - It means that:
- - - - We only need to worry about movement conflicts with widgets moving in the same direction
- - - - - - as the widget in question. 
- - - - It guarantees that a widget will never try to move into the same spot that another widget
- - - - - - is trying to move to (Or at least, they won't try to do so simultaneously. No conflict).
- - - - We won't need to do as much (if any) recursion to resolve move conflicts. Let me explain: 
- - - - - - Here is how it works if the widgets can move different directions simultaneously:
- - - - - - - - A widget wants to move to a spot that is occupied by a widget that is moving
- - - - - - - - simultaneously. It needs to recursively look at that widget and see if that widget
- - - - - - - - can move. If there is another moving widget in front of that one, it must run the
- - - - - - - - check again on THAT widget, and so on. Once we know whether or not the widget at the
- - - - - - - - end of this "chain" can move, then we can go up the chain and inform each relevant
- - - - - - - - widget.
- - - - - - - - You *may* even need to do recursion if the widgets share an end location too.
- - - - - - Here is how it works if separate each movement direction, doing them one at a time:
- - - - - - - - If there are a bunch of widgets moving simultaneously, they must all be moving in
- - - - - - - - the same direction.
- - - - - - - - You make a list of widgetMoveRequests, for each widget moving in that instant. They
- - - - - - - - are all moving in the same direction.
- - - - - - - - Bear in mind, when the program scans the map to find out which widgets are moving,
- - - - - - - - it does so starting in the top left of the map.
- - - - - - - - What this means is that the widgets towards the top/left of the map will be towards
- - - - - - - - the front of the list of widgetMoveRequests. Conversely, the widgets near the
- - - - - - - - bottom/right will be near the end of the list. Why is this important?
- - - - - - - - Remeber: With the previous approach, the movement directions are not separated,
- - - - - - - - so you can't be certain which direction every widget is moving. So, if you have
- - - - - - - - a chain of widgets moving into each other, you need to start by moving the widget
- - - - - - - - at the "end" of the chain (ir the widget that doesn't move into any other widgets),
- - - - - - - - and in order to find the end of the chain, you need recursion.
- - - - - - - - However, in this approach, you do know which direction each widget is moving because
- - - - - - - - each direction has its own dedicated movement type. So, for example, if you have
- - - - - - - - a chain of widgets moving into each other, and they are all moving down, you know
- - - - - - - - that the end of the chain will be the widget closest to the bottom. So, you can deal
- - - - - - - - with each widget's widgetMoveRequest from the bottom up and be assured that there
- - - - - - - - will be no conflicts. But how do you deal with them from the bottom up?
- - - - - - - - Well, go to the list that stores the widgetMoveRequests. Requests towards the end
- - - - - - - - belong to the widgets at the bottom of the map. So, you can loop from the end of
- - - - - - - - the list to the front backwards and deal with each request in that order.
- - - - - - - - Same if they are all moving right. If they are all moving up or left, loop 
- - - - - - - - forwards from the front to the back of the list instead.
- - 
- - Here is an idea for how the game deals with all of the actions:
- - - - First, it is they player's turn. They input their action. All instances of the player do
- - - - the same thing, so they all act simultaneously.
- - - - The game lists all of the player widgetMoveRequests, and deals with them in whichever order
- - - - it needs to.
- - - - Then, it is everyone else's turn. The game loops through the entire map and inspects each
- - - - widget (ignoring air and player instances). For each widget, it figures out what that widget "wants" to do.
- - - - IE, what action it wants to do.
- - - - Each action type is assigned a number (maybe a letter, if there ends up being more than 10 action types).
- - - - These will be referred to as "action codes".
- - - - There will be a 2D vector of ints (or maybe chars). The vector is arranged in a grid of the same dimensions
- - - - as the game map. Each spot in the vector corresponds to a spot on the map.
- - - - Once a widget has decided on its course of action, it updates this 2D vector by putting their chosen
- - - - action's number in the 2D in the exact spot that corresponds to that widget's position in the game map.
- - - - 
- - - - Once it has scanned the whole map, and has completely populated the 2D vector of action codes, it loops
- - - - through the vector of action codes.
- - - - Each action type gets its own action request custom datatype (like how moves have widgetMoveRequestsuests).
- - - - On a similar note, each action request custom datatype gets a vector to store them.
- - - - So, while the game loops through the action code vector, it looks at each action code, and creates an
- - - - action request for the corresponding widget at that position. Then, it adds that request to a list for that
- - - - type of action request.
- - - - Once the game has looped through the vector, it will visit each list for each action type, and loop through
- - - - them, carrying out their actions. The order in which it visits theses lists is based on the
- - - - "order of operations" that I want the action types to follow. 
- - - - For example, lets say that there are only 4 action types: Move up, move right, move down, and move left.
- - - - And we'll say that the order that the actions will follow is:
- - - - - - Move up
- - - - - - Move right
- - - - - - Move down
- - - - - - Move left
- - - - So, the program will start by visiting the list of action requests that are about moving up.
- - - - Then, it will visit list of action requests that are about moving down.
- - - - And so on...
