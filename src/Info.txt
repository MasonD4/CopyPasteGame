This is an informational text file for Copy Paste Game.

Contents:
// Misc. Reminders
// Main ideas
// Widget Traits
// refineMapString(vector<string>) function
// makeMapFromString(string) function
// Move function
// Counters
// Possible Puzzles

[===============================================- @ -===============================================]
Misc. Reminders
[===============================================- @ -===============================================]
Miscellaneous reminders for anything that I want to remind myself of/make note of, but there isn't a devoted
section for it. It can also be said that it is for things that I may want to add in the future, but haven't
added yet, and thus they arguabley don't yet deserve to be considered actual information about the game,
as they don't yet describe any currently existing detail or facet of the game.

The edge of the map will be treated as a wall.

Spaces in the map string will be replaced with the empty space tile (maybe '-'?) in the rendered map.

If the rows in the map string are of unequal length, it will show up as a hole in the map, which will be treated
as a bunch of walls. Edit: Nvm, just replace it with actual space or walls.
Edit 2: Actually, uneven rows get filled in with *empty spaces*.

If there are multiple '@'s in the map, the player controls all of them. There should also allowed to be 0.
I might also allow for there to be 2 unique players. If so, player two would be '&'. 

After I have come up with a working movement system, try searching for alternatives in Google or the chat bot.
Not necessarily because it needs to be replaced with an alternative, but just for the sake of learning.

Enemy ideas: 
// An enemy that, once destoyed, gives you 1 or 2 dash-charges.
//
// An enemy that "slides", moving across an entire row or column until an obstacle. This can't push anything,
// though (or atleast, can only do it 1 block at a time). It destroys any player in its path.
// Perhaps if it "slides" into a pushable block, it pushes the block 1 space, eg:
// // 'S' is the slide enemy, 'P' is a pushable block.
// // S - - - - - - - - - - P -
// // - - - - - - - - - - S - P
// Notice the gap it left. This could prevent it from easily getting itself trapped in a pocket.

Perhaps "slide" could be an ability a player can have?

Perhaps there should be an ability that allows players to push, swap with, or otherwise rearrange immovable widgets.

There will be doors that require a specific number to be pushed into it to be destroyed (and it destroys that
number).


[===============================================- @ -===============================================]
Main Ideas
[===============================================- @ -===============================================]

The player inputs a string of text, which is then turned into the game map. 

List of tiles:
@ Player
- Empty space
# Wall
] New Row
C Coin Counter
J Jump Counter
* Coin (maybe change to $)
! Enemy
& Player 2?????????????????????

[===============================================- @ -===============================================]
Widget Traits
[===============================================- @ -===============================================]

This is a list of traits that each widget may or may not have:
// * Movable
// // * Can this widget be moved/pushed? Yes or no? Note: I may split this into 2 other traits:
// // Movable: Can it be moved directly?
// // Pushable: Can it be pushed by something else?
//
// * Dangerous:
// // * Yes or no? Dangerous widget can destroy players or player-aligned characters.
//
// * Number:
// // * Is the character a number? If so, it is given its respective number value. Otherwise, it's given a -1 value.
//
// * Player:
// // * Is it a player-controlled character? Yes or no?
//
// * Killable:
// // * Dashing through this widget will result in it being destroyed and added to the kill count

[===============================================- @ -===============================================]
refineMapString(vector<string>) function
[===============================================- @ -===============================================]

This is used to remove the spaces and newlines (not ']', '\n') from the input, which allows someone to input
something like this:
- - - ]
- @ - ]
- - - #

Instead of this: 
---]-@-]---#

For context, in the main function, the input for the map is obtained like this:
// The user inputs a string and presses enter.
// If they want, they can input another string. Otherwise, they can just press enter again, submiting an empty
-- // strng and ending the loop.
// Each string that gets submitted gets pushed onto a vector of strings.

So, the refineMapString function takes in this vector and goes through 2 for-loops:
// The first loop takes every string in the vector and adds them all to a single, temporary string, thus removing
-- // new line characters.
// The second row iterates through the temporary string, and adds each character to the an output string, as long as
-- // that character isn't a space (' ').

Finally, the function returns the output string. This was surprisingly and pleasantly easy to write, and didn't take
much time at all.

[===============================================- @ -===============================================]
makeMapFromString(string) function
[===============================================- @ -===============================================]

This function is supposed to take in the string that will be used to create the map.
It has 3 main parts:

Part 1: Is the input empty?
If the input is empty (input.length() < 1), then it passes a premade input string into the makeMapFromString
function (yes, it calls itself). This results in the function returning a premade, playable map, which tells the
user that their input is empty.

Part 2: How many rows and columns are there?
This uses a for loop and 2 other variables: biggestRowLength and currentRowLength. 
The loop will check 4 conditions:
// 1: If the current character in the input string (input[i]) is a newline character or the end of the input string,
// // AND the length of the current row is longer than the biggestRowLength, then it updates the biggestRowLength
// // and sets the currentRowLength = 1. 
// 2: If the current character is a newline character or the end of the input string, AND the current row is NOT
// // longer  than the biggestRowLength, then it just sets currentRowLength = 1;
// 3: Otherwise, increment currentRowLength
// 4: If the current character is a newline character, increment the rows variable (the one passed in by reference).
-
After the for-loop is over, it sets columns = biggestRowLength. It doesn't do anything to rows because it already
incremented it *during* the loop (see condition 4).
-
P.S.: the reason that currentRowLength is set to 1 and not 0 is because it knows that the current row length is at
least 1. It is also because currentRowLength isn't incremented when encountering a newline character or the last
character. So basically, it knows the the row is at least 1 character long (including the newline character or last
character), but if it encounters a character that isn't a newline or the last character, then it can safely increment
currentRowLength (because each line has either a newline character or the last character. So, if it encounters a
character that isn't one of these, then there MUST be at least 1 character in the row. Conversely,
if it encounters a newline character or the last character, then it KNOWS that there will be no more characters in
the row, which is why it doesn't increment currentRowLength) 

Part 3: Translate the input string to the output vector.
This part starts by creating 2 vectors: the actual 2D output vector, and a 1D "default row" vector.
// The 2D vector is initialized empty.
// The 1D vector is initialized to be the length of a row (`comlumns` variable), and each element is set to the 
// // empty space character.
It also creates an int (`positionInInput`) and a bool (`reachedEndOfInput`), which will be talked about later.
-
Here is the overall idea behind Part 3:
A default row is pushed onto the end of the output vector. Then, the program looks at each space in the row and
determines whether the current character in the input string should be added to the current space in the vector, or
if that space should be left as its default value (the empty space character).
For context, it will keep track of 3 "pointers." These are not actual pointers that need to be dereferenced.
Instead, they are just regular ints used to keep track of the current row, current column,
and current character in the input string.
There are 3 conditions:
// If the current character in the input string is a new row character, but the column "pointer" has not reached the
-- // end of the row yet, then it will just leave the current space in the vector as is. It will then advance the
-- // column pointer without advancing the input string's pointer.
// Else if the input string's pointer reaches the end of the input string (even if the row and column pointers have 
-- // not made it to the end of the vector yet), then it will simply stop the loop. This will leave all remaining
-- // spaces in the vector as the empty space character.
// Otherwise, it will simply assign the current character in the input string to the current space in the vector.
-- // It will then advance all 3 pointers.
-
An important thing to keep in mind in order to conceptualize the logic of Part 3:
Part 3 is centered around the output vector, not the input string. What this means is that it will iterate through
the vector, while also keeping track of the current character in the input string. Not the other way around.
It moves through the positions in the vector at a constant rate, but does not move through the input string at a
constant rate (it may refrain from moving the input string's pointer forward in the first condition)

[===============================================- @ -===============================================]
Move function
[===============================================- @ -===============================================]

This is the default ruleset for movement:
// The thing being moved can be one of four things:
// // Out of bounds/nonexistent object
// // Immovable object
// // Movable object
// // Empty air
//
// The spot being moved to can be one of four things:
// // Out of bounds
// // Occupied by an immovable object
// // Occupied by a movable object
// // Empty air
//
// If the moved object is at the end of a long line of objects being pushed (ie the recursive count is too high),
// the move fails.
//
// If the object being moved is out of bounds (it does not exits) the move fails.
// 
// If the object being moved is immovable the move fails.
//
// If the object being moved is movable then the function will check the adjacent space to be moved to and
// attempt to move there.
//
// Finally, if the object being moved is just empty air, nothing happens but the move is counted as successful.
//
//
// Assuming that the object being moved is movable, the function moves on and starts checking the adjacent space
// to be moved to.
//
// If the space being moved to is out of bounds, the move fails.
//
// If the space being moved to is occupied by an immovable object, the move fails.
//
// If the space being moved to is occupied by a movable object, then the function will call itself to move that
// object. Let this be called a "push move". If the push move is successful, then the initial move is too.
// Otherwise, the initial move fails.
//
// If the space being moved to is empty, then the move is successful.

Those are the default rules, but there are exceptions:
// If player 1 moves into another instance of player 1, then PERHAPS the first instance pushes the second instance,
// without incrementing recursiveCount.
//
// If a player moves onto a coin...
//
// If a player moves onto an enemy/hazard, the player disappears and the enemy/hazard is left alone (or maybe they
// get pushed before the player disappears).
//
// Maybe if a coin moves onto a player it will push the player (in which case it is not an exception to default
// rules).
//
// If an enemy moves onto the player...

[===============================================- @ -===============================================]
Counters
[===============================================- @ -===============================================]

List of counters:
// Jump/dash counter (How many times you can use the "dash" ability)
// Enemy kill count (How many enemies you have killed)
// Countdown (The *Final* countdown. Once this reaches 0 the player dies)
// Coins

It's  possible that counters conpletely require a number to be next to them in order for them
to operate. For example, if there is a countdown counter(s), it can not kill the player unless there is
a zero next to it and no higher number. If there is no number next to it at all, the countdown won't kill you.
If a counter has absolutely no numbers next to it, its value is -1, not 0.

[===============================================- @ -===============================================]
Possible Puzzles
[===============================================- @ -===============================================]

There is a door next to a kill counter. A number widget is situated between and thus connected to both of them.
The number widget serves as the receptacle for the kill counter and the threshold for the door. The number that
widget represents is a low number. The player is provided with some dash charges, enough to kill all of the enemies
in the room that they are in. They are alos given a number widget of equal value of the door's threshold.
If the player kills any enemies, the kill counter updates its number widget, increasing the door's threshold, and
invalidating you "key". You must manuver past enemies and get the key to the door.