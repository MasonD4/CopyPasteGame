This is an informational text file for Copy Paste Game.

Contents:
// Misc. Reminders
// Main ideas
// Widget Ideas
// Widget Traits
// refineMapString(vector<string>) function
// makeMapFromString(string) function
// Move Function
// Counters
// Possible Puzzles
// How Movement Works

[===============================================- @ -===============================================]
Misc. Reminders
[===============================================- @ -===============================================]
Miscellaneous reminders for anything that I want to remind myself of/make note of, but there isn't a devoted
section for it. It can also be said that it is for things that I may want to add in the future, but haven't
added yet, and thus they arguabley don't yet deserve to be considered actual information about the game,
as they don't yet describe any currently existing detail or facet of the game.

The edge of the map will be treated as a wall.

Spaces in the map string will be replaced with the empty space tile (maybe '-'?) in the rendered map.

If the rows in the map string are of unequal length, it will show up as a hole in the map, which will be treated
as a bunch of walls. Edit: Nvm, just replace it with actual space or walls.
Edit 2: Actually, uneven rows get filled in with *empty spaces*.

If there are multiple '@'s in the map, the player controls all of them. There should also allowed to be 0.
I might also allow for there to be 2 unique players. If so, player two would be '&'. 

After I have come up with a working movement system, try searching for alternatives in Google or the chat bot.
Not necessarily because it needs to be replaced with an alternative, but just for the sake of learning.

Enemy ideas: 
// An enemy that, once destoyed, gives you 1 or 2 dash-charges.
//
// An enemy that "slides", moving across an entire row or column until an obstacle. This can't push anything,
// though (or atleast, can only do it 1 block at a time). It destroys any player in its path.
// Perhaps if it "slides" into a pushable block, it pushes the block 1 space, eg:
// // 'S' is the slide enemy, 'P' is a pushable block.
// // S - - - - - - - - - - P -
// // - - - - - - - - - - S - P
// Notice the gap it left. This could prevent it from easily getting itself trapped in a pocket.

Perhaps "slide" could be an ability a player can have?

Perhaps there should be an ability that allows players to push, swap with, or otherwise rearrange immovable widgets.

There will be doors that require a specific number to be pushed into it to be destroyed (and it destroys that
number).


[===============================================- @ -===============================================]
Main Ideas
[===============================================- @ -===============================================]

The player inputs a string of text, which is then turned into the game map. 

List of tiles:
@ Player
- Empty space
# Wall
] New Row
C Coin Counter
J Jump Counter
* Coin (maybe change to $)
! Enemy
& Player 2?????????????????????

[===============================================- @ -===============================================]
Widget Ideas
[===============================================- @ -===============================================]

The player (and maybe player 2) (@ and &, respectively)

A standard enemey that makes a beeline for the player.

An enemy that can move an infinite amount of spaces horizontally or vertically. It's possible that this enemey HAS
to move as many spaces as it can before hitting a wall or other obstacle, killing anything in its path (possibly
destroying certain widgets that aren't "alive", such as weak walls). It's possible that, in order to "spot" the
player, the player must be on their row or column. However, it's also possible that they can spot the player from
anywhere, as long as they are nearby, and if the player isn't already in their row or column, this enemy will
attempt to make its way there. Maybe the enemy can only move horizontally OR vertically infinitely, but must move
by one space the other way. Eg, if they can move vertically infinitely, they can move horizontally by one.
-----
Maybe it just stays still. Maybe, it just waits for the player to enter its line of sight, at which points it
zooms towards them. Maybe, in orfer to get around this, the play must put a pushable block in front of it,
to sheild them from this enemy. Or perhaps, if the player goes to the spot one diagonal away from this enemy, it
will bait the enemy into moving ONE space orthogonally, allowing the player to kill the enemy via teleportation.

Weak walls. They behave like walls (of course), but can be destroyed by several means.

Thwomp (see chronolog). Perhaps the thwomp can move one space in any direction except downwards. To move downwards,
it must thwomp. Or perhaps it can only move up and down. Who knows? I suppose it is important to note that the
thwomp doesn't necessarily have to be an enemey that targets the player. Instead, it just moves up repeatedly,
until it reaches the ceiling, when it will then thwomp. It does this 

bait. Attracts enemies, and can possibly be "killed".

Bomb

Movers. These come in pairs and in several possible flavors. A mover is actually a pair of widgets:
a puller and a pusher (or a head and a tail). It's pretty simple: pullers attempt to flee from pushers, who in
turn chase the pullers. Flavors include:
- - Good pushers and good pullers: Can be pushed around by the player.
- - Evil pushers and evil pullers: Will destory the player if the player walks in to them (but won't pursue players)
- - Good smart pullers: They are like good pushers, EXCEPT that if they get pushed into a wall, they'll turn and move
- - - - in another direction, if possible, instead of simply stopping.
- - Evil smart pullers: They are like good smart pullers, but evil. They hurt.
- - Chaser pullers: Pullers that, aside from fleeing from pushers, will also chase the player. Can be good or evil

[===============================================- @ -===============================================]
Widget Traits
[===============================================- @ -===============================================]

This is a list of traits that each widget may or may not have:
// * Movable
// // * Can this widget be moved/pushed? Yes or no? Note: I may split this into 2 other traits:
// // Movable: Can it be moved directly?
// // Pushable: Can it be pushed by something else?
//
// * Dangerous:
// // * Yes or no? Dangerous widget can destroy players or player-aligned characters.
//
// * Number:
// // * Is the character a number? If so, it is given its respective number value. Otherwise, it's given a -1 value.
//
// * Player:
// // * Is it a player-controlled character? Yes or no?
//
// * Killable:
// // * Dashing through this widget will result in it being destroyed and added to the kill count

[===============================================- @ -===============================================]
refineMapString(vector<string>) function
[===============================================- @ -===============================================]

This is used to remove the spaces and newlines (not ']', '\n') from the input, which allows someone to input
something like this:
- - - ]
- @ - ]
- - - #

Instead of this: 
---]-@-]---#

For context, in the main function, the input for the map is obtained like this:
// The user inputs a string and presses enter.
// If they want, they can input another string. Otherwise, they can just press enter again, submiting an empty
-- // strng and ending the loop.
// Each string that gets submitted gets pushed onto a vector of strings.

So, the refineMapString function takes in this vector and goes through 2 for-loops:
// The first loop takes every string in the vector and adds them all to a single, temporary string, thus removing
-- // new line characters.
// The second row iterates through the temporary string, and adds each character to the an output string, as long as
-- // that character isn't a space (' ').

Finally, the function returns the output string. This was surprisingly and pleasantly easy to write, and didn't take
much time at all.

[===============================================- @ -===============================================]
makeMapFromString(string) function
[===============================================- @ -===============================================]

This function is supposed to take in the string that will be used to create the map.
It has 3 main parts:

Part 1: Is the input empty?
If the input is empty (input.length() < 1), then it passes a premade input string into the makeMapFromString
function (yes, it calls itself). This results in the function returning a premade, playable map, which tells the
user that their input is empty.

Part 2: How many rows and columns are there?
This uses a for loop and 2 other variables: biggestRowLength and currentRowLength. 
The loop will check 4 conditions:
// 1: If the current character in the input string (input[i]) is a newline character or the end of the input string,
// // AND the length of the current row is longer than the biggestRowLength, then it updates the biggestRowLength
// // and sets the currentRowLength = 1. 
// 2: If the current character is a newline character or the end of the input string, AND the current row is NOT
// // longer  than the biggestRowLength, then it just sets currentRowLength = 1;
// 3: Otherwise, increment currentRowLength
// 4: If the current character is a newline character, increment the rows variable (the one passed in by reference).
-
After the for-loop is over, it sets columns = biggestRowLength. It doesn't do anything to rows because it already
incremented it *during* the loop (see condition 4).
-
P.S.: the reason that currentRowLength is set to 1 and not 0 is because it knows that the current row length is at
least 1. It is also because currentRowLength isn't incremented when encountering a newline character or the last
character. So basically, it knows the the row is at least 1 character long (including the newline character or last
character), but if it encounters a character that isn't a newline or the last character, then it can safely increment
currentRowLength (because each line has either a newline character or the last character. So, if it encounters a
character that isn't one of these, then there MUST be at least 1 character in the row. Conversely,
if it encounters a newline character or the last character, then it KNOWS that there will be no more characters in
the row, which is why it doesn't increment currentRowLength) 

Part 3: Translate the input string to the output vector.
This part starts by creating 2 vectors: the actual 2D output vector, and a 1D "default row" vector.
// The 2D vector is initialized empty.
// The 1D vector is initialized to be the length of a row (`comlumns` variable), and each element is set to the 
// // empty space character.
It also creates an int (`positionInInput`) and a bool (`reachedEndOfInput`), which will be talked about later.
-
Here is the overall idea behind Part 3:
A default row is pushed onto the end of the output vector. Then, the program looks at each space in the row and
determines whether the current character in the input string should be added to the current space in the vector, or
if that space should be left as its default value (the empty space character).
For context, it will keep track of 3 "pointers." These are not actual pointers that need to be dereferenced.
Instead, they are just regular ints used to keep track of the current row, current column,
and current character in the input string.
There are 3 conditions:
// If the current character in the input string is a new row character, but the column "pointer" has not reached the
-- // end of the row yet, then it will just leave the current space in the vector as is. It will then advance the
-- // column pointer without advancing the input string's pointer.
// Else if the input string's pointer reaches the end of the input string (even if the row and column pointers have 
-- // not made it to the end of the vector yet), then it will simply stop the loop. This will leave all remaining
-- // spaces in the vector as the empty space character.
// Otherwise, it will simply assign the current character in the input string to the current space in the vector.
-- // It will then advance all 3 pointers.
-
An important thing to keep in mind in order to conceptualize the logic of Part 3:
Part 3 is centered around the output vector, not the input string. What this means is that it will iterate through
the vector, while also keeping track of the current character in the input string. Not the other way around.
It moves through the positions in the vector at a constant rate, but does not move through the input string at a
constant rate (it may refrain from moving the input string's pointer forward in the first condition)

[===============================================- @ -===============================================]
Move function
[===============================================- @ -===============================================]

See the section "How movement works" for more info.

This is the default ruleset for movement:
// The thing being moved can be one of four things:
// // Out of bounds/nonexistent object
// // Immovable object
// // Movable object
// // Empty air
//
// The spot being moved to can be one of four things:
// // Out of bounds
// // Occupied by an immovable object
// // Occupied by a movable object
// // Empty air
//
// If the moved object is at the end of a long line of objects being pushed (ie the recursive count is too high),
// the move fails.
//
// If the object being moved is out of bounds (it does not exits) the move fails.
// 
// If the object being moved is immovable the move fails.
//
// If the object being moved is movable then the function will check the adjacent space to be moved to and
// attempt to move there.
//
// Finally, if the object being moved is just empty air, nothing happens but the move is counted as successful.
//
//
// Assuming that the object being moved is movable, the function moves on and starts checking the adjacent space
// to be moved to.
//
// If the space being moved to is out of bounds, the move fails.
//
// If the space being moved to is occupied by an immovable object, the move fails.
//
// If the space being moved to is occupied by a movable object, then the function will call itself to move that
// object. Let this be called a "push move". If the push move is successful, then the initial move is too.
// Otherwise, the initial move fails.
//
// If the space being moved to is empty, then the move is successful.

Those are the default rules, but there are exceptions:
// If player 1 moves into another instance of player 1, then PERHAPS the first instance pushes the second instance,
// without incrementing recursiveCount.
//
// If a player moves onto a coin...
//
// If a player moves onto an enemy/hazard, the player disappears and the enemy/hazard is left alone (or maybe they
// get pushed before the player disappears).
//
// Maybe if a coin moves onto a player it will push the player (in which case it is not an exception to default
// rules).
//
// If an enemy moves onto the player...

[===============================================- @ -===============================================]
Counters
[===============================================- @ -===============================================]

List of counters:
// Jump/dash counter (How many times you can use the "dash" ability)
// Enemy kill count (How many enemies you have killed)
// Countdown (The *Final* countdown. Once this reaches 0 the player dies)
// Coins

It's  possible that counters conpletely require a number to be next to them in order for them
to operate. For example, if there is a countdown counter(s), it can not kill the player unless there is
a zero next to it and no higher number. If there is no number next to it at all, the countdown won't kill you.
If a counter has absolutely no numbers next to it, its value is -1, not 0.

[===============================================- @ -===============================================]
Possible Puzzles
[===============================================- @ -===============================================]

There is a door next to a kill counter. A number widget is situated between and thus connected to both of them.
The number widget serves as the receptacle for the kill counter and the threshold for the door. The number that
widget represents is a low number. The player is provided with some dash charges, enough to kill all of the enemies
in the room that they are in. They are alos given a number widget of equal value of the door's threshold.
If the player kills any enemies, the kill counter updates its number widget, increasing the door's threshold, and
invalidating you "key". You must manuver past enemies and get the key to the door.

[===============================================- @ -===============================================]
How Movement Works
[===============================================- @ -===============================================]

See the section "Move function" for more info.

Perhaps during the player's turn, it will store a copy of the game map. If, by The end of the player's
sub-turn (not a full turn where everything/everyone moves, just the sub-turn where player(s) move) the game map
still looks the same as it did, that means that no instance of the player has moved, and the player must try
again. Of course, if there are no players on the map, the game will run with out the player.

This doesn't apply to just movement, but I may implement a sort of "action queue". It will be a global queue, who's
elements consist of a pair of coordinates and an action (possibly its own data type) that takes place there.
The queue will only consist of actions that occur simultaneously. It may even be a queue of queues, so as to store
future actions. 
The actions in the queue will occur starting with whatever is at the start.
I may actually not be able to use a queue, since I don't just want to deal with the action at the start of the
queue, but also any actions further down the line that that action affects.
A vector would suffice, then.
Perhaps I could make a custom data type clled "WidgetAction", containing a pair of coordinates, a char, and a
string, the latter of which will contain a description of the action to be performed.

What happens if there are two/multiple actions in the queue affecting the same widget? I have 4 possible solutions:
1 Keep the first instance of it, remove any following ones.
2 Keep the latest one, remove all of the prior ones.
3 Weigh them (and choose the one with the highest "score").
4 Do both of them.

In order for a movement to successfully happen, these criteria must be met:
* The widget actually wants to make that move(eg If player chooses right, the player widget won't want to move left)
* The movement does not conflict with other simultaneous moves.
* The movement is possible (eg not blocked by a wall)
If the widget decides that it does not want to make that move (unlikely that I will implement such a system), it is
allowed up to 3 more attempts to pick one (4 attempts total, one for each side/possible move).
// Actually, giving a widget the ability to rethink its move might be a bit advanced for now. For now, I may just
// just have a widget "decide" which move it wants to make, and then it commits to that move. If it is unable to
// actually accomplish that move, then it simply doesn't make the move. And then, in the future, I may go back
// and give them the ability to rethink. Of course, an exception is players: If there is at least 1 player on the
// board, if the player is unable to move, they must try again.

I can *probably* say that a widget will have "made up its mind" by the time it creates a WidgetAction and sends it
out to the action queue/vector.

For the time being, I will assume that different types of actions/events can not happen simultaneously.
This is to make it easier on me, as each type of action will have its own function for determining whether or
not it conflicts with any other simultaneous actions. So for example, a widget can't move at the exact same time
that a bomb is going off. One comes before the other.
While it is *possible* that I *may* want to change this in the future, for now and for the sake of progress, 
I will assume otherwise.


As of September 30, 2025, this is the overall idea of how movement conflicts might be handled:
- - First, all move requests are put into a vector.
- - It looks at each move request. Each request consists of a widget type, a start x & y, and
- - - - an end x & y.
- - For each move request, it looks at every move request that comes after. (Yes, this is O(N^2)).
- - If the destination of the current request is the same as the destination of a request further
- - - - down the line, it might simply cancel that move request, or perhaps it recursively checks if
- - - - that move will be successful. HOWEVER, this scenario (same destination) isn't necessarily
- - - - a conflict. EG:
- - - - - - - - - D - - - - D moves Down
- - - - - - - - R - - - - - R moves Right
- - - - - - - - - - - - - - 
# # # # # # # # # # # # # # 
- - - - - - - - - - - - - - 
- - - - - - - - - R D - - - End result. Both moves end up going through.
- - - - - - - - - - - - - - Edit: This might not happen.
- - If the destination of the current request is the starting point of another, it recursively
- - - - checks if that move will be succesful. If this recursion somehow manages to end up at
- - - - the original move request, all relevant move requests are cancled.
- - - - - - Or perhaps they all go through...
-----
For the time being, how about we just worry about that second case: If the destination of
the current request is the starting point of another, it recursively checks if that move will
be succesful. If this recursion somehow manages to end up at the original move request, all relevant
move requests are cancled. Or perhaps they all go through.