A hazard that slams downward, destroying the player if it is in its path. Perhaps its "AI" will work like this:
- - If there is an immovable widget right above it, it slams down.
- - If there is an immovable widget right under it, it moves up one space.
- - If there neither the spot directly above or below it is blocked, it slams upward, destroying the player if in its path.

Two widgets that work together to create movement.
- - A "puller" widget that moves away from/flees the "pusher" widget.
- - A "pusher" widget that chases the "puller".
- - 
- - Maybe there can be diffrerent types. Like a "smart" puller that, if it can't move forward, will turn and move in
- - another direction, if possible.
- - "Evil" pushers and pullers that hurt the player.
- - 
- - Perhaps pushers and pullers move simultaniously, so that a pusher can move into the exact location that the puller is in.
- - EG:
- - - - - - o = pusher
- - o > - - > = puller
- - - - - -
- -
- - - - - - 
- - - o > - 
- - - - - - 
- - Actually, that might not work, as whether or not two widget move simultaneously depends on the direction they're moving in.
- - Nonethless, a puller and pusher will generally be moving in the same direction.
- - 
- - Or maybe there won't be a dedicated pusher or puller, but rather I just put in 3 or 4 widgets that behave like:
- - - - A: Chases B, flees C
- - - - B: Chases C, flees A
- - - - C: Chases A, flees B

In my little black book, I wrote about an idea regarding a change to the vault ability (I refer to it as "vault" in those particular pages of the book).
The page is dog-eared.
Specifically, it is about the idea of "Vault Anchors".

I think that "step-on-interactions" (events that happens when a widget steps on another) will happen at the moment the widget steps on the other.
For example, if several instances of the player are moving at once, and one of them steps on a coin, that coin will be counted immediately, before the remaining
instances of the player get to move. Doing things like this will probably make things easier.

Counter ideas:
// Jump/dash counter (How many times you can use the "dash"/"jump"/"shift"/"Vault" ability)
// Enemy kill count (How many enemies you have killed)
// Countdown (The *Final* countdown. Once this reaches 0 the player dies)

"Pool ball" idea:
- - There are widgets that can be pushed. Once pushed, they will slide as far as they can before hitting an
- - obstruction. If they hit another instance of itself (ie, another "pool ball"), that widget will also
- - start sliding. If it hits an obstruction, and it's ending location is right next to another "pool ball",
- - that pool ball will be repelled by the pool ball that just slid into place, and will slide in the opposite
- - direction.
- - Examples:
- - - - - - - -
@ P - - - - # - P = pool ball
- - - - - - - -
- -
- - - - - - - -
- @ - - - P # - Pool pall was just pushed into an obstruction
- - - - - - - -
- -
- -
- - - - - - - -
@ P - - - - # -
- - - - - P - -
- - - - - - - -
- - - - - # - -
- -
- - - - - - - -
@ - - - - P # - The pool ball was just pushed into an obstruction.
- - - - - - - - It landed next to another pool ball, resulting in said pool ball sliding downwards,
- - - - - P - - Away from the initial pool ball.
- - - - - # - -
- -
- -
- - Another possiblity:
- - Maybe there isn't a specific pool ball widget. Instead, maybe their is an ability called "shove".
- - The shove ability works as follows: You type in the shove command, as well as a direction.
- - Then, if there is a *pushable* widget adjacent to you in the direction specified, it will get "shoved",
- - which will result in it sliding in the specified direction as far as it can go before hitting an obstruction.
- - An obstruction doesn't have to be a wall or any other unpushable widget. It can be a pushable widget too.
- - Even if a shoved widget slides into a pushable widget, the shoved widget will stop moving.
- - Then, depending on which widgets are adjacent to it, those widgets might also get shoved away from the
- - intially shoved widget. For example, maybe widgets can only shove like widgets. So, if an 'm'
- - (which is a lowercase letter, ans therefore pushable) gets shoved, and it runs into another 'm',
- - that 'm' will also get shoved. But if it runs into any other type of widget, that other widget will be
- - unaffected.
- - Or perhaps every widget has a specific behavior regarding how they react when shoving/getting shoved by
- - other specifc widgets. For example, maybe there could be a function that checks what happens when X shoves Y.
- - It will look at X and Y, and then attempts to find an if-statement that accounts for the two of them.
- - If it succeeds, then it invokes whatever special beavior is prescribed by that if-statement.
- - If not, it invokes the "default" behavior, which is to check if Y is pushable. If so, X shoves Y.
- - If not, Y is unaffected.
- - For example, perhaps there can be explosive widgets. And when an explosive it shoved into another explosive,
- - KABOOM!!!
- -
- - Also, due to the fact that such a mechanic can lead to large chains of reaction, it might be a good
- - idea to print the map every time a shoved widget shoves another widget. It doesn't have to
- - actually stop the game or ask for player input (and it shouldn't),
- - it just prints them out. So perhaps, if the player wants to,
- - they can scroll up and see each step of the process.
- - Also, whenever it prints out the map in response to a widget shoving a widget, it should perhaps also print
- - a little label explaining that that is the purpose of the map being printed.

A turret.
- - This one is really quite simple.
- - It's a widget that will detect if the player is on the same row or column as it (if there are no obstructions
- - between the two). If so, it simply deletes the player.
- - "But Mason!" I hear you asking "isn't that functionally the same thing as a wall? Ie, a space that you just
- - can't walk on, and therefore must go around or teleport through?" Stupid question.
- - Yes, it can functionally act similar to a wall. However, there is one key differnce:
- - Even if the turret's line of sight is generally just "a line of tiles that I can't walk on", and therefore
- - similar to a wall, it is *still* not a physical obstruction. You can shove something past it,
- - and the turret won't care. And if you push a widget in front of the turret, blocking it's line of sight,
- - you can walk past it! Perhaps, if I add explosives, turrets will shoot them, just for fun :)

A Rook
- - Basically a turret, but will actually move to the spot that the player is on.
- - This ability will likely be called "bash".
- - Maybe, multiple rooks can bash the same player (or rather the same location), resulting in a
- - "dogpile" where multiple rooks attack the same spot, and only one rook survives!
- -
- - Also, maybe it's not such a bad thing that, hypothetically, rooks can "chain". Eg:
- - # # # # # # ]
- - # - - - - - ]
- - # - - - @ - ] Lets say that the leftmost rook is targeting the rightmost rook, which itself is targeting the
- - # - - - - - ] player. And lets say that the left one moves first.
- - # - ! - ! - ] This results in it getting to move a second time, once the parser gets to the spot
- - # - - - - - ] once occupied by the rightmost rook and says "Well the rook that was here wants to bash the
- - # # # # # # ] player, and there is clearly still a rook in that spot, so it is allowed to bash the player".
- -
- - Then again, I actually think that I want to avoid that.
- - Nonethless, realistically I will not make rooks target other rooks.
- - 
- - I may want to create a function: One that takes in a char and checks if it can be bashed.
- - `bool canBash(char)`, perhaps. 
- - 
- - Also, I might want to implement a widget that acts as "bait", which, if placed in front of a rook, will
- - trigger the rook. Maybe the bait will be a ',' or a '~' or a ':' or a '+'. Or a '*'