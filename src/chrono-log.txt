Friday June 20 2025:
// Kyle and I worked on the move function. We added some conditions to the move function.
//
// We gave the move function a recursion limit. Basically, when the move function is initially called, a 0 will be
// passed into the recursion-counting parameter (recursionCount). From there, if the function will check if the
// recursionCount has reached/exceeded the RECURSION_LIMIT. If so, it stops the function. If the function calls itself, 
// it will increment the recursionCount and then pass that value into the new function call.
// 
// We also added some new char constants, including the coin counter and the jump counter
// (on that note, the "dash" ability has been renamed to the "jump" ability).
// 
// We added two more functions. One, called isMovable, checks if a char is movable. The other, called isDangerous, 
// checks if a certain char is dangerous.
//
// Next week, we plan to continue working on the move function.


Friday June 27 2025:
// Kyle and I worked on the move function. We added some conditions to the move function.
// Specifically the condition checking if the player is pushing a movable.
//
// Next week we will test out the move function according to the diagram that I made.


Friday July 11 2025:
// Kyle and I tested out the move function. We created the testing ground map, which contains 16 tests.
// All but one passed. The one test that failed:
// The player moves into a dangerous spot (onto an enemy). At that point, the player should disappear
// (be destroyed), and the enemy stays as is. Instead, both the player and the enemy stayed put. Nothing changed.
// The problem? Instead of setting the players position to an empty space, it was checking to see if the
// player's position WAS an empty space.
// I simply removed an '=' sign.
//
// Next time, we will likely work on the jump function.


Friday July 18 2025:
// Got started on the jump function.
// Also, potential new names for the jump ability: Warp, blink.

Friday July 25 2025:
// Added part of a coin condition in the jump function.
// 
// Added some comments.
// 
// Added a new branch, "input", which is being used to test out a player input loop. I got it to work in some ways,
// but not others. Here is a timeline for how it went:
// // > I created the loop and 5 conditions: One for if the player chooses to quit, and one for each WASD key.
// // There was not anything to allow the player to jump. It didn't work; No matter what I did the player didn't
// // move. Not only that, but the console didn't display any of my custom made cout error statments, which means
// // that my move wasn't being treated at invalid in the move function.
// // 
// // > The issue was because it was using the playerCoordinates vector to find and move players, but
// // it never actually populated that vector. I Fixed this by adding a line to the player input loop that invoked
// // the findPlayers function. At this point it worked (sort of); I could move the player (and even all instances
// // of the player, if there were multiple), but only once. After this it would say that I was trying to move From
// // an empty space. I knew what the issue was right away.
// // 
// // > The issue was that, upon being populated, the playerCoordinates vector could not be updated. So, I fixed
// // that by telling the findPlayers function to clear and repopulate the vector if it was called on more than
// // once. Now, it work just fine, for the most part. I can move the player, I can move at least 3 players at
// // once, I can push stuff, and the players will obey other objects, other instances of the player,
// // and the map edge. However, there is still one unsolved issue: When there are three instances of the player in
// // a row (right next to each other), when I move right (press 'd') they all move 3 spaces. This doesn't happen
// // if the players are not next to each other, or if I choose another direction.
// // Example:
// // - - - - - - ]
// // @ @ @ - - - ]
// // - - - - - - ]
// // move: d
// // - - - - - - ]
// // - - - @ @ @ ]
// // - - - - - - ]
// 
// I think the above mentioned issue has to do with the push mechanic, the way the playerCoordinates vector
// refreshes, and the order that the program parses the map when finding and moving players. 
// Here is how I (think I may have) figured it out:
// // - - - - - - ]
// // - - @ @ @ - ]
// // - - - - - - ]
// // move: d
// // - - - - - - ]
// // - - - @ @ @ ]
// // - - - - - - ]
// In this above example, when I press 'd' and move right, the console displays two of my cout error statemets.
// Each of them tell me that a player had tried to move into a wall. This means that, while players had tried to
// move, only one moved, and two of them were blocked by a wall (or a player blocked by a wall).
// Here is what I thought had happened: 
// // > Due to the order that the program parses the map, the leftmost player gets to technically move first.
// //
// // > The leftmost player moves, pushing the other two players in the process.
// //
// // > The middle player tries to move. It is blocked by the rightmost player, so it tries to push them. The
// // rightmost player is blocked by the wall.
// // 
// // > Finally, the rightmost player tries to move right but doesn't, because it is being blocked by the wall.
//
// At least, that was my first theory. However, had there been no obstruction, it would have played out like this:
// Leftmost player moves to the right and pushes the middle and rightmost players to the right as well. Then,
// the middle player moves right, pushing the rightmost player to the right. Then, the rightmost player moves
// right. This scenario would look like this:
// // - - - - - - ]
// // @ @ @ - - - ]
// // - - - - - - ]
// // move: d
// // - - - - - - ]
// // - @ - @ - @ ]
// // - - - - - - ]
// 
// That is not what happens. Here is my second theory:
// // > The findPlayers function is invoked. It finds 3 players, and sees that they are located at (x, y), (x+1, y),
// // and (x+2, y), respectively.
// //
// // > The program is designed to look at each of these coordinates and move whatever is there to the right.
// // 
// // > First, whatever is at (x, y) will be moved right. The leftmost player is there, so it moves right, pushing
// // the middle and leftmost players.
// //
// // > Then, whatever is at (x+1, y) will be moved right. The leftmost player is there because it moved there,
// // so it moves right, pushing the middle and leftmost players.
// //
// // > Finally, whatever is at (x+2, y) will be moved right. The leftmost player is there, of course, so it moves
// // right a third time. 
// // 
// // > This all happens because the leftmost player is moving in the same direction as the metaphorical "pointer".
//
// Idea: The move function currently moves things immediately; Once the move function is called, by something
// gets moved (unless the move fails). Instead of doing that, I can make a global vector or something like that.
// Whenever the move function is called, instead of directly moving something, the move function will send a 
// move data to the vector. Each game cycle, a separate function will be called. It will read through the vector
// and fulfill each move that had been stored there.
// Alternatively, this can just be a feature.
//
// Idea 2: Same as the last idea, but instead of a table, it can be a hashmap. Whenever the move function is called
// and move data is sent to the hashmap, it checks if the thing that is moving is already being moved. If so, don't
// bother.


Thursday July 31 2025:
// Made some minor changes. I improved the findPlayers function.
//
// NOTE: In the future, when working on the move and jump functions, when thinking of conditions to check,
// take two main things into account: What is being moved, and what it is moving into. Look at the list of
// constant chars.
// Also, keep in mind what order these conditions should come in. If there are two or more conditions where
// you can not decide which should come first, you can make a separate condition that merges the two somehow,
// or you can nest them.
//
// Note: In the future, I should keep in mind that I shouldn't completely try to make the game bend to my exact
// vision. I should embrace some of the technical quirks and limitations. For example, things near the top left
// of the map get movement priority. I don't necessarily need to fix this asymmetry. Instead, I can embrace it and
// let it influence puzzle design.

Friday August 29 2025:
// For now on, each entity on the map (player, NPC, block, wall, air, whatever it may be) will be referred to as A
// "Widget".
// 
// A "Solid Widget" refers to any widget other than air.
//
// A "Legit Widget" refers to any widget INCLUDING air.
//
// We didn't do any real work, but we came up with how movement (and other actions should happen):
// Firstly, before all of this, it is important to know that every type of action (such of moving) gets its own
// function(s). There will be a function(s) for each type of action that considers all of the logic to decide on if
// the action can happen, and then there will be a function(s) that actually carry out the action. All of these
// take in a vector that contains a list of every action that is happening simultaneously. Each element in the vector
// will perhaps be a custom type that contains the coordinates of the action, and any other relevant info.
//
// First, a vector containing all of the moves that are happening (coordinates and direction) is created.
// This vector gets passed into the first movement function, which checks to see if any of the moves interact
// (and more importantly, conflict) with each other. It checks the first move in the list.
// 
// If that widget is moving in such a way that it does not interact with or interfere with any other widgets that
// are on the list, then it allows the widget to move (but does not *carry-out* the move yet).
// 
// If the widget's move does interact with or interfere with another widget on the list, the function is called
// recursively to preform the same check on that widget. 
// If the initial widget does not directly interact with or interfere with another widget on the list, but it does
// push a pushable, the function preforms a check (maybe useing recursion, maybe within that same function call,
// maybe with an outside helping function) on that pushable widget (not on the list), and any widget that it is 
// pushing, while keeping track of whether or not the push-limit has been reached. If it encounters another widget
// that is on the list it preforms a check on that widget.
//
// Also, while it is looking through the chains, it is also keeping track of where the start of the chain is.
// If it encounters a move that directly contradicts a move that came before it in the chain, the chain is broken,
// or resolved through some other means. If the chain reaches a widget that does not interact with or interfere
// with other widgets on the list OR it loops back to the start of the chain without running into contradictory
// moves, all moves within the chain are allowed to happen.
// // NOTE: Just because all moves are "allowed" to happen does not mean that they will immediately happen,
// // or that they will all actually happen. There are still other steps. This phase only exists to make sure that
// // none of the moves that are happening simultaneously are in direct contradiction. For example, a moving 
// // widget may be allowed to move by the end of this phase of the movement, but at a later phase it is decided
// // that it can not actually move because it is behind a wall. 
// // Basically, if this phase gives a widget the green light to move, it only means that it has made it through
// // the first filter, and is free to continue its movement as usual, which may involve not moving at all.
//
// Once a chain (or a single move, if the widget in question wasn't interacting with or interfering with other
// moving widgets) is resolved, it moves on to the next widget that hasn't been evaluated.
//
// After all of the possible conflicting moves have happened, the next phase (possibly in another function) will
// check to see which moves are actually valid, and then give those the green light.
//
// After all of that, the final phase of the process will actually move the widgets, via a list of all of the
// accepted moves.
//
// However, before I start on all of that, I plan to attempt to make the map and possibly the push limit *global*.

Friday September 5 2025
// Again, Kyle and I didn't technically do much (though I did make the map and the rows and columns variable global)
// but we did do a lot of theorizing into what we could possibly do in the future regarding the move function.
//
// We want to restructure the vector containing player coordinates. We want to change it into a mirror of the game
// board, where each coordinates is where we are storing the players data regarding where they are going. This 
// data will likely be an int, which will track the state of a player's movement during a turn. During a player
// move, we will look at each player and update their state according to 3 states: Able to move, unable to move,
// waiting on another player. Every player starts in a waiting state.
// // Able to move: The player is clearly able to move and is not blocked by another player/currently moving widget
// // Unable to move: The player is clearly unable to move (eg blocked by a wall).
// // Waiting: The default state. If we check a player and they are in this state, we see if they can move. If it
// // turns out that they are blocked by another player, they remain in the waiting state and the other player is
// // checked and so on.
//
// Note: there is a 4th state: Not a player. This is code 0.

Friday September 12 2025
// Kyle and I started working on code for the game. I created a new branch, "movement", to begin working on the 
// new movement code. Thus far we have redone the playerCoordinates vector, so instead of being a vector of pairs,
// each pair representing a coordinate that a player is at, it is now a 2D vector of equal size/dimensions to
// the game map. Each spot on this grid is an int, which signifies whether or not there is a player in the
// corresponding spot on the map, and if so, what their status is.

Wednesday September 17 2025
// I have decided that, from this point onward, I will develop the game under the assumption that the only 4
// widgets in the game are the player, the movable boxes, the walls, and the open empty air. I will also assume
// that the only widgets capable of moving simultaneously are the players and whatever boxes they happen to be
// pushing.
// I obviously intend to scale things up eventually, but for now I just want to create something that works within
// this smaller and likely temporary scope.
// Here is the criteria for what I would consider to be a complete version:
// // It technically works (doesn't throw errors or encounter any obvious and intense bugs)
// // It follows the rules that I believe make sense and are logical.
// // It follows the rules consistently and perfectly.

Friday September 26 2025
- - Kyle and I continued theorizing about how to implement simultaneous movement. We decided that there we two main
- - ways to go about it:
- - - - One: The recursive route. If there are several moving widgets next to each other, and if they have move
- - - - - - conflicts, then you go through each one and find the "end of the chain": The widget that can move without
- - - - - -  disturbing or conflicting any simultaneously moving widgets. This widget will move as normal, then the
- - - - - -  widget that was conflicting with it, and then the widget conflicting with that one and so on.
- - - - Two: The comparison route. Each movement is saved as a custom bundle of data in a vector, with each bundle
- - - - - - containing the widget type, the original location, and the target location. Then, I will loop though the
- - - - - - vector and see if any of the moves have the same destination, or if any two widgets that are completely
- - - - - - adjacent to each other (no space in between) are both trying to move towards each other. I will then
- - - - - - resolve the conflict however necessary. All non-conflicting moves just do whatever they need to.
- - - - - - Note: this might be O(N^2), with N = the amount of moves.
- - 
- - I also came up with a postential new hazard: A thing that goes upwards one block at a time. Once it reaches an
- - obstacle, it SLAMS downward, as far down as it can go (I'm so glad the edges of the map aren't portals),
- - destroying anything in its path. Like a thwomp from Mario.
- - Maybe it can even destroy walls when it thwomps. Liek every time it slams down, the wall it hits breaks.
- - 
- - I also figured out that, at the moment, given the current (lowered) scope of the game, there is only one type of
- - of movement conflict that can happen: You have a row of moving widgets moving into a wall.
- - E.g.:
- - - - @ @ @ #
- - - - All of these players are moving right.

Monday September 29 2025
- - I worked on the testing branch. I added a widgetMoveRequest struct datatype, as well as a vector to contain
- - them.

Thursday October 2 2025
- - Updated the widgetMoveRequest custom datatype and gave it a boolean to check if 
- - the move has beeneliminated yet. 
- - I also ADDED a for-loop to playerTurn() that adds every player to the vector for move requests

Friday October 3 2025
- - Kyle and I thought of some more ideas as to how to deal with movement. Here are some ideas we
- - thought of:
- - Movement will be separated by direction. This means that there is no "movement" action, but 
- - rather "move up", "move right", "move down", and "move left" actions. Since different directions
- - are treated as separate movement types, they cannot happen simultaneously. So this:
- - - - - - 
- - - D - - 'D' moves down
- - R - - - 'R' moves right
- - - - - - 
- - results in this:
- - - - - - 
- - - - - - 
- - - R D - 
- - - - - -
- - Or maybe this, if 'R' moves first:
- - - - - - 
- - - - - - 
- - - D - - 
- - - R - - 
- - 
- - If each direction of movement is a unique movement type, then it makes certain things much easier.
- - It means that:
- - - - We only need to worry about movement conflicts with widgets moving in the same direction
- - - - - - as the widget in question. 
- - - - It guarantees that a widget will never try to move into the same spot that another widget
- - - - - - is trying to move to (Or at least, they won't try to do so simultaneously. No conflict).
- - - - We won't need to do as much (if any) recursion to resolve move conflicts. Let me explain: 
- - - - - - Here is how it works if the widgets can move different directions simultaneously:
- - - - - - - - A widget wants to move to a spot that is occupied by a widget that is moving
- - - - - - - - simultaneously. It needs to recursively look at that widget and see if that widget
- - - - - - - - can move. If there is another moving widget in front of that one, it must run the
- - - - - - - - check again on THAT widget, and so on. Once we know whether or not the widget at the
- - - - - - - - end of this "chain" can move, then we can go up the chain and inform each relevant
- - - - - - - - widget.
- - - - - - - - You *may* even need to do recursion if the widgets share an end location too.
- - - - - - Here is how it works if separate each movement direction, doing them one at a time:
- - - - - - - - If there are a bunch of widgets moving simultaneously, they must all be moving in
- - - - - - - - the same direction.
- - - - - - - - You make a list of widgetMoveRequests, for each widget moving in that instant. They
- - - - - - - - are all moving in the same direction.
- - - - - - - - Bear in mind, when the program scans the map to find out which widgets are moving,
- - - - - - - - it does so starting in the top left of the map.
- - - - - - - - What this means is that the widgets towards the top/left of the map will be towards
- - - - - - - - the front of the list of widgetMoveRequests. Conversely, the widgets near the
- - - - - - - - bottom/right will be near the end of the list. Why is this important?
- - - - - - - - Remeber: With the previous approach, the movement directions are not separated,
- - - - - - - - so you can't be certain which direction every widget is moving. So, if you have
- - - - - - - - a chain of widgets moving into each other, you need to start by moving the widget
- - - - - - - - at the "end" of the chain (ir the widget that doesn't move into any other widgets),
- - - - - - - - and in order to find the end of the chain, you need recursion.
- - - - - - - - However, in this approach, you do know which direction each widget is moving because
- - - - - - - - each direction has its own dedicated movement type. So, for example, if you have
- - - - - - - - a chain of widgets moving into each other, and they are all moving down, you know
- - - - - - - - that the end of the chain will be the widget closest to the bottom. So, you can deal
- - - - - - - - with each widget's widgetMoveRequest from the bottom up and be assured that there
- - - - - - - - will be no conflicts. But how do you deal with them from the bottom up?
- - - - - - - - Well, go to the list that stores the widgetMoveRequests. Requests towards the end
- - - - - - - - belong to the widgets at the bottom of the map. So, you can loop from the end of
- - - - - - - - the list to the front backwards and deal with each request in that order.
- - - - - - - - Same if they are all moving right. If they are all moving up or left, loop 
- - - - - - - - forwards from the front to the back of the list instead.
- - 
- - Here is an idea for how the game deals with all of the actions:
- - - - First, it is they player's turn. They input their action. All instances of the player do
- - - - the same thing, so they all act simultaneously.
- - - - The game lists all of the player widgetMoveRequests, and deals with them in whichever order
- - - - it needs to.
- - - - Then, it is everyone else's turn. The game loops through the entire map and inspects each
- - - - widget (ignoring air and player instances). For each widget, it figures out what that widget "wants" to do.
- - - - IE, what action it wants to do.
- - - - Each action type is assigned a number (maybe a letter, if there ends up being more than 10 action types).
- - - - These will be referred to as "action codes".
- - - - There will be a 2D vector of ints (or maybe chars). The vector is arranged in a grid of the same dimensions
- - - - as the game map. Each spot in the vector corresponds to a spot on the map.
- - - - Once a widget has decided on its course of action, it updates this 2D vector by putting their chosen
- - - - action's number in the 2D in the exact spot that corresponds to that widget's position in the game map.
- - - - 
- - - - Once it has scanned the whole map, and has completely populated the 2D vector of action codes, it loops
- - - - through the vector of action codes.
- - - - Each action type gets its own action request custom datatype (like how moves have widgetMoveRequests).
- - - - On a similar note, each action request custom datatype gets a vector to store them.
- - - - So, while the game loops through the action code vector, it looks at each action code, and creates an
- - - - action request for the corresponding widget at that position. Then, it adds that request to a list for that
- - - - type of action request.
- - - - Once the game has looped through the vector, it will visit each list for each action type, and loop through
- - - - them, carrying out their actions. The order in which it visits theses lists is based on the
- - - - "order of operations" that I want the action types to follow. 
- - - - For example, lets say that there are only 4 action types: Move up, move right, move down, and move left.
- - - - And we'll say that the order that the actions will follow is:
- - - - - - Move up
- - - - - - Move right
- - - - - - Move down
- - - - - - Move left
- - - - So, the program will start by visiting the list of action requests that are about moving up.
- - - - Then, it will visit list of action requests that are about moving down.
- - - - And so on...

Saturday October 4 2025
- - In the testing branch I have decided to split the widgetMoveRequest datatype into 4 new datatypes,
- - one for each direction.

Sunday October 5 2025
- - I added a print function to the 4 move Token datatypes. Next time I work on this, I need to
- - test those out.

Monday October 6 2025
- - I tested them, they seem to work just fine. The move token vectors all populate completely and
- - in the right order. The print function seems to work fine.

Wednesday October 8 2025
- - I didn't *do* anything today, but I did think of something that may prove useful in the
- - future: So after you have a vector full of move tokens, you go through it and set each
- - destination coordinate to '@'.
- - Afterwards you just need to set the original coordinate to '-'. But, I hear you asking,
- - won't this possibly cause some instances of the player to get overwritten by a '-'?
- - No, because of the order in which the moves get executed. If one player's destination is
- - another player's initial location, then when the player in front of the other moves
- - (it WILL end up moving first), the empty space it leaves behind SHOULD get overwritten by the
- - following player (not vice versa).


Friday October 10 2025
- - We did a lot of work.
- - I copied all of the code from main.cpp in the testing branch to main.cpp in the movement branch,
- - as the two branches are now on the same page, figuratively speaking.
- - 
- - I renamed the 4 functions responsible for executing moves. I also split them each in two. 
- - For each cardinal direction, there will be one function that parses that direction's respective
- - vector of tokens, feeding each token into a helper function. For each cardinal direction, there is a 
- - (above mentioned) helper function whose purpose is to actually do the logic-checking and ultimately 
- - execute the move token passed into its parameter.
- - 
- - I added a function, isOnMap(), that aptly checks if a given coordinate pair is on The Map.
- - 
- - I added some error checking to the executeMoveDownToken() function (the function that executes 
- - the downward movement tokens).
- - Next time, I will keep working on this.